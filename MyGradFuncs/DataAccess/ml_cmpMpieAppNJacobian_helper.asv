function [I, J] = ml_cmpMpieAppNJacobian_helper(im, imDx, imDy, shpParam, ptchXYIs, ShpBasis, mode)
% function [I, J] = ml_cmpMpieAppNJacobian_helper(im, imDx, imDy, shpParam, ptchXYIs, ShpBasis, mode)
% Compute Appearance and Jacobian of w.r.t to shape parameters.
% Inputs:
%   im: the image
%   shpParam: the shape parameters, this is a column vector of size (6+k)*1.
%       The first six components are for affine motion.
%       If we denote A = shpParam, the affine transformation matrix is:
%       M = [A(1), A(2), A(3); A(4), A(5), A(6); 0 0 1];
%       The rest of the shpParam is non-rigid shape params.
%   ptchXYIs: This is a cell of 68 elements. ptchXYI{i} is a
%       n(i)*2 matrix which is the XI, YI of pixels inside square patch
%       around the landmark i_th and inside the face. ptchXYIs is computed
%       by function: ml_mpieFacePtchs. Look at that function for more
%       details.
%   ShpBasis: the basis of shape variations. Each column is a basis vector.
%       Look at function ml_mpieShpPCA for more details.
%   mode: valid options are: 'Jacobian', 'App', 'App_Jacobian'. This to set whether
%       this function should compute the Appearance and Jacobian for the corresponding
%       shape params. One should use the correct option because the computational cost 
%       of this function depends on this option.
% Outputs:
%   I: the appearance w.r.t shape params. This is m*1 column vector.
%       If the mode = 'Jacobian' only, I is [].
%   J: the Jacobian of image appearance with respect to shape parameters.
%       This is a m*(6+k) maxtrix. However, if mode = 'App', J is returned empty [].
% See also: ml_cmpMpieAppNJacobian_helper.m
% By: Minh Hoai Nguyen (minhhoai@cmu.edu)
% Date: 9 Oct 2007.

[imH, imW] = size(im);    

persistent XGrid YGrid sclLShpBasisX sclLShpBasisY sclXI sclYI
global ml_cmpMpieAppNJacobian_helper_VAR;

if isempty(ml_cmpMpieAppNJacobian_helper_VAR)
    XGrid = [1 1 imH]; %Meshgrid of qqinterp2
    YGrid = [1 1 imW];

    [XI, YI, lShpBasisX, lShpBasisY] = ...
        ml_cmpLongPtchXYIs(ptchXYIs, ShpBasis);

    % work with scaled version to avoid numerical problems.
    sclXI = XI/imW;
    sclYI = YI/imH;
    sclLShpBasisX = lShpBasisX/imW;   
    sclLShpBasisY = lShpBasisY/imH;
    
end;

k = size(ShpBasis,2); % number of basis vectors for shape variation.

A = shpParam;
%Scale the paramters to consitent with scaled XI, YI.
A([1,4]) = A([1,4])*imW;
A([2,5]) = A([2,5])*imH;    

% Affine transformation matrix.
M = [A(1), A(2), A(3); A(4), A(5), A(6); 0 0 1];   

%XI and YI after the non-rigid transformation.
sclXI2 = sclXI + sclLShpBasisX*A(7:end);
sclYI2 = sclYI + sclLShpBasisY*A(7:end);        

%XI and YI after non-rigid and affine transformation.
curXYI = [sclXI2, sclYI2, ones(length(sclXI2),1)]*M';               
disp('new method');
disp(curXYI(1:5,:));

if strcmp(mode, 'App_Jacobian')
    [I, winDx, winDy]  = qqinterp2(XGrid,YGrid, ...
        curXYI(:,1), curXYI(:,2), im, imDx, imDy);
elseif strcmp(mode, 'App')
    I = qqinterp2(XGrid, YGrid, curXYI(:,1), curXYI(:,2), im);
    J = [];
elseif strcmp(mode, 'Jacobian')
    [winDx, winDy]  = qqinterp2(XGrid,YGrid, ...
        curXYI(:,1), curXYI(:,2), imDx, imDy);
    I = [];
else
    error('ml_cmpMpieAppNJacobian_helper.m: Unknown option for mode. Valid options: App, Jacobian, App_Jacobian');
end;

if strcmp(mode, 'App_Jacobian') || strcmp(mode, 'Jacobian')
    %Jacobian of affine motion.
    Ja = [winDx.*sclXI2, winDx.*sclYI2, winDx, ...
        winDy.*sclXI2, winDy.*sclYI2, winDy];

    %Jacobian for non-rigid motion, computation is based on the formulae: df/du = df/dx*dx/du + df/dy*dv/du.
    Jalpha =(A(1)*sclLShpBasisX + A(2)*sclLShpBasisY).*repmat(winDx,1,k) + ...
        (A(4)*sclLShpBasisX + A(5)*sclLShpBasisY).*repmat(winDy,1,k);

    J = [Ja, Jalpha]; %combined Jacobian
end;
